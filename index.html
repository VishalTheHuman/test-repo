<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>iFING-like Finger Capture (Web)</title>
<style>
  :root {
    --accent: #0ea5e9;
    --danger: #ef4444;
    --ok: #10b981;
    --bg: #0b1020;
    --panel: #111827;
    --text: #e5e7eb;
    --muted: #9ca3af;
  }
  html, body { margin: 0; height: 100%; background: var(--bg); color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Noto Sans, "Apple Color Emoji", "Segoe UI Emoji"; }
  .page { display: grid; grid-template-rows: auto 1fr auto; height: 100%; }
  header { padding: 12px 16px; border-bottom: 1px solid #1f2937; background: linear-gradient(180deg, #0e162b 0%, #0b1020 100%); }
  header h1 { margin: 0; font-size: 16px; font-weight: 600; letter-spacing: 0.2px; }
  main { display: grid; grid-template-columns: 1fr 360px; gap: 16px; padding: 16px; }
  .panel { background: var(--panel); border: 1px solid #1f2937; border-radius: 10px; overflow: hidden; }
  .preview { position: relative; display: grid; grid-template-rows: auto 1fr; }
  .toolbar { display: flex; gap: 8px; align-items: center; padding: 10px; border-bottom: 1px solid #1f2937; }
  .toolbar .spacer { flex: 1; }
  button { appearance: none; border: 1px solid #374151; background: #0b1327; color: var(--text); padding: 8px 12px; border-radius: 8px; cursor: pointer; font-weight: 600; }
  button.primary { border-color: #0ea5e9; background: #06243a; color: #cce8f7; }
  button.danger { border-color: #ef4444; background: #3a0a0a; color: #fcdada; }
  button:disabled { opacity: 0.5; cursor: not-allowed; }
  .viewport { position: relative; background: black; display: grid; place-items: center; }
  video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
  canvas.overlay { position: absolute; inset: 0; pointer-events: none; }
  .instructions { position: absolute; top: 12px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.55); border: 1px solid rgba(255,255,255,0.08); padding: 8px 12px; border-radius: 999px; font-size: 13px; backdrop-filter: blur(6px); }
  .progressBadge { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.65); border: 1px solid rgba(255,255,255,0.12); padding: 10px 14px; border-radius: 10px; font-size: 14px; letter-spacing: 0.3px; display: none; }
  .statusbar { position: absolute; left: 12px; bottom: 12px; background: rgba(0,0,0,0.45); border: 1px solid rgba(255,255,255,0.08); padding: 8px 10px; border-radius: 8px; font-size: 12px; backdrop-filter: blur(6px); }
  .statusbar .kv { display: inline-grid; grid-template-columns: auto auto; column-gap: 10px; row-gap: 4px; align-items: baseline; }
  .statusbar .kv div { opacity: 0.85; }
  .statusbar .kv div:nth-child(odd) { color: var(--muted); }
  .legend { padding: 10px; color: var(--muted); font-size: 12px; }
  .tag { display: inline-flex; align-items: center; gap: 6px; border: 1px solid #1f2937; background: #0a1a33; color: #bfdbfe; padding: 2px 8px; border-radius: 999px; font-size: 11px; }
  .row { display: flex; gap: 8px; align-items: center; }

  /* Preview modal */
  .modal { position: fixed; inset: 0; display: grid; place-items: center; background: rgba(0,0,0,0.6); backdrop-filter: blur(2px); z-index: 50; }
  .modal.hidden { display: none; }
  .modal .sheet { background: var(--panel); border: 1px solid #1f2937; border-radius: 12px; padding: 16px; width: min(92vw, 520px); }
  .modal .sheet h3 { margin: 0 0 12px; font-size: 16px; }
  .modal .sheet .preview { display: grid; place-items: center; background: #000; border: 1px solid #1f2937; border-radius: 8px; overflow: hidden; margin-bottom: 12px; }
  .modal .sheet img { width: 100%; height: auto; display: block; }
  .modal .sheet .actions { display: flex; gap: 8px; justify-content: flex-end; }
</style>
</head>
<body>
<div class="page">
  <header>
    <h1>iFING-like Finger Capture (Web) — Camera stability gating + adaptive JPEG</h1>
  </header>
  <main>
    <section class="panel preview">
      <div class="toolbar">
        <button id="btnStart" class="primary">Start camera</button>
        <button id="btnStop">Stop</button>
        <div class="spacer"></div>
        <span class="tag" title="Mirrors app behavior: need 4 stable frames">Stable frames ≥ 4</span>
      </div>
      <div class="viewport" id="viewport">
        <video id="video" playsinline muted></video>
        <canvas id="overlay" class="overlay"></canvas>
        <div id="instructions" class="instructions">Center your finger in the guide and hold steady…</div>
        <div id="progressBadge" class="progressBadge">Capturing…</div>
        <div class="statusbar">
          <div class="kv">
            <div>Stability</div><div id="kvStability">–</div>
            <div>Stable count</div><div id="kvStableCount">0</div>
            <div>Best score</div><div id="kvBest">–</div>
            <div>Status</div><div id="kvCandidates">Idle</div>
          </div>
        </div>
      </div>
      <div class="legend">Move your device so the finger fills the guide. The camera will auto‑capture once stable.</div>
    </section>
  </main>
  <footer style="padding:10px 16px; border-top:1px solid #1f2937; color: var(--muted); font-size: 12px;">
    This demo approximates the iFING capture logic: stability gating (≥4 frames), cropping exactly the guide region, scaling to 600×800, and adaptive JPEG ≤100KB.
  </footer>
</div>

<!-- Preview modal -->
<div id="previewModal" class="modal hidden" role="dialog" aria-modal="true">
  <div class="sheet">
    <h3>Preview — fingerprint</h3>
    <div class="preview">
      <img id="previewImg" alt="Captured fingerprint preview" />
    </div>
    <div class="actions">
      <button id="btnRetake">Retake</button>
      <a id="downloadLink" download="fingerprint.jpg"><button class="primary">Download</button></a>
    </div>
  </div>
  
</div>

<script>
  const videoEl = document.getElementById('video');
  const overlayEl = document.getElementById('overlay');
  const ctxOverlay = overlayEl.getContext('2d');
  const viewportEl = document.getElementById('viewport');
  const btnStart = document.getElementById('btnStart');
  const btnStop = document.getElementById('btnStop');
  const instructionsEl = document.getElementById('instructions');
  const progressBadge = document.getElementById('progressBadge');
  const previewModal = document.getElementById('previewModal');
  const previewImg = document.getElementById('previewImg');
  const btnRetake = document.getElementById('btnRetake');
  const downloadLink = document.getElementById('downloadLink');

  const kvStability = document.getElementById('kvStability');
  const kvStableCount = document.getElementById('kvStableCount');
  const kvBest = document.getElementById('kvBest');
  const kvCandidates = document.getElementById('kvCandidates');

  /**
   * State mirroring android logic concepts
   */
  let mediaStream = null;
  let running = false;
  let rafId = null;

  // Analysis canvas (downscaled), offscreen capture canvas (600x800)
  const analysisCanvas = document.createElement('canvas');
  analysisCanvas.width = 160; // small for quick per-frame analysis
  analysisCanvas.height = 120;
  const analysisCtx = analysisCanvas.getContext('2d', { willReadFrequently: true });

  const captureCanvas = document.createElement('canvas');
  captureCanvas.width = 600; // mirrors app createScaledBitmap(600, 800)
  captureCanvas.height = 800;
  const captureCtx = captureCanvas.getContext('2d');

  // Frame canvas sized to overlay for cover-scaling and cropping the guide region
  const frameCanvas = document.createElement('canvas');
  const frameCtx = frameCanvas.getContext('2d');

  // Stability gating parameters (tuned for typical webcams; adjust if needed)
  const stability = {
    // Lower is more stable; threshold similar role to face-score+box-change checks
    maxMeanDiff: 7.5, // 0..255 average per-pixel diff threshold
    maxCenterShift: 0.06, // relative shift tolerance across frames (approx 6%)
    requiredStableFrames: 4,
    minLuma: 30, // avoid too dark
    maxLuma: 220, // avoid too bright
  };

  // Single capture result
  let captured = null; // { url, blob, quality, sizeKB }
  let bestScore = Number.POSITIVE_INFINITY;
  let stableCount = 0;
  let prevAnalysis = null;
  let prevCenter = null;
  let prevFilteredCenter = null; // EMA-smoothed center for shake compensation
  let lastGuide = { guideX: 0, guideY: 0, guideW: 0, guideH: 0 };
  let scanStartAt = 0;

  const metricsHistory = {
    meanDiffs: [],
    centerShifts: [],
    maxLen: 30,
  };

  function setRunningState(isRunning) {
    running = isRunning;
    btnStart.disabled = isRunning;
    btnStop.disabled = !isRunning;
  }

  function drawOverlay() {
    const { width, height } = overlayEl;
    ctxOverlay.clearRect(0, 0, width, height);

    // Outer dim
    ctxOverlay.fillStyle = 'rgba(0, 0, 0, 0.35)';
    ctxOverlay.fillRect(0, 0, width, height);

    // Finger guide: adapt to orientation
    const portrait = height >= width;
    const guideW = Math.floor(width * (portrait ? 0.45 : 0.35));
    const guideH = Math.floor(height * (portrait ? 0.65 : 0.70));
    const guideX = Math.floor((width - guideW) / 2);
    const guideY = Math.floor((height - guideH) / 2);
    const radius = 14;

    ctxOverlay.save();
    ctxOverlay.globalCompositeOperation = 'destination-out';
    roundedRect(ctxOverlay, guideX, guideY, guideW, guideH, radius);
    ctxOverlay.fill();
    ctxOverlay.restore();

    // Guide stroke
    ctxOverlay.strokeStyle = 'rgba(14, 165, 233, 0.9)';
    ctxOverlay.lineWidth = 3;
    roundedRect(ctxOverlay, guideX, guideY, guideW, guideH, radius);
    ctxOverlay.stroke();

    // Minor inner margins for alignment feedback
    ctxOverlay.setLineDash([8, 8]);
    ctxOverlay.strokeStyle = 'rgba(14, 165, 233, 0.45)';
    roundedRect(ctxOverlay, guideX + 12, guideY + 12, guideW - 24, guideH - 24, radius);
    ctxOverlay.stroke();

    lastGuide = { guideX, guideY, guideW, guideH };
    return lastGuide;
  }

  function roundedRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
  }

  function updateKV() {
    kvStableCount.textContent = String(stableCount);
    kvBest.textContent = Number.isFinite(bestScore) ? bestScore.toFixed(3) : '–';
    kvCandidates.textContent = captured ? 'Captured' : 'Scanning…';
  }

  function analyzeFrame() {
    // Draw current frame to small analysis canvas
    analysisCtx.drawImage(videoEl, 0, 0, analysisCanvas.width, analysisCanvas.height);
    const img = analysisCtx.getImageData(0, 0, analysisCanvas.width, analysisCanvas.height);
    const { meanDiff, lumaMean, centerOfMass } = computeMetrics(img, prevAnalysis);

    // Compute relative center shift with EMA smoothing to tolerate shake
    const alpha = 0.2; // smoothing factor (lower -> more smoothing)
    let filteredCenter;
    if (prevFilteredCenter) {
      filteredCenter = {
        x: prevFilteredCenter.x * (1 - alpha) + centerOfMass.x * alpha,
        y: prevFilteredCenter.y * (1 - alpha) + centerOfMass.y * alpha,
      };
    } else {
      filteredCenter = centerOfMass;
    }
    let centerShift = 0;
    if (prevFilteredCenter) {
      const dx = (filteredCenter.x - prevFilteredCenter.x) / analysisCanvas.width;
      const dy = (filteredCenter.y - prevFilteredCenter.y) / analysisCanvas.height;
      centerShift = Math.hypot(dx, dy);
    }

    // Alignment proxy: how centered is the center-of-mass relative to frame center
    const normCx = centerOfMass.x / analysisCanvas.width;
    const normCy = centerOfMass.y / analysisCanvas.height;
    const alignmentScore = Math.abs(normCx - 0.5) + Math.abs(normCy - 0.5);

    // Adaptive stability thresholds based on recent motion; relax slightly over time
    pushMetric(metricsHistory.meanDiffs, meanDiff, metricsHistory.maxLen);
    pushMetric(metricsHistory.centerShifts, centerShift, metricsHistory.maxLen);
    const { thrMeanDiff, thrCenterShift, framesRequired } = computeAdaptiveThresholds();

    const isLumaOk = lumaMean >= stability.minLuma && lumaMean <= stability.maxLuma;
    const isStable = meanDiff <= thrMeanDiff && centerShift <= thrCenterShift && isLumaOk;

    // Combined score (lower is better): stability + alignment
    const combinedScore = meanDiff * 0.9 + alignmentScore * 100.0 + centerShift * 50.0;

    // Update HUD + dynamic instructions
    kvStability.textContent = `${meanDiff.toFixed(2)} | shift ${centerShift.toFixed(3)} | align ${alignmentScore.toFixed(3)} | luma ${lumaMean.toFixed(1)}`;
    instructionsEl.textContent = suggestInstruction({ isLumaOk, meanDiff, centerShift, alignmentScore });

    // Stable frames handling (adaptive required frames)
    if (isStable) {
      stableCount = Math.min(stableCount + 1, Math.max(framesRequired + 2, stability.requiredStableFrames + 2));
    } else {
      stableCount = 0;
    }
    updateKV();

    // Auto-capture a single image cropped to the guide
    if (!captured && stableCount >= framesRequired) {
      showProgress('Capturing…');
      bestScore = Math.min(bestScore, combinedScore);
      captureFromGuide().then(() => {
        showProgress('Processing…');
        // brief processing delay to communicate state
        setTimeout(() => { hideProgress(); showPreview(); }, 300);
      }).catch((e) => { console.error(e); hideProgress(); });
      stableCount = 0;
      updateKV();
    }

    // Keep prev stats for next frame
    prevAnalysis = img;
    prevCenter = centerOfMass;
    prevFilteredCenter = filteredCenter;
  }

  function pushMetric(arr, value, maxLen) {
    arr.push(value);
    if (arr.length > maxLen) arr.shift();
  }

  function meanAndStd(arr) {
    if (arr.length === 0) return { mean: 0, std: 0 };
    const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
    const variance = arr.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / arr.length;
    return { mean, std: Math.sqrt(variance) };
  }

  function computeAdaptiveThresholds() {
    const elapsed = scanStartAt ? (Date.now() - scanStartAt) / 1000 : 0;
    const relax = Math.min(1.8, 1 + Math.max(0, elapsed - 6) * 0.08); // start relaxing after 6s, up to 1.8x
    const { mean: mdMean, std: mdStd } = meanAndStd(metricsHistory.meanDiffs);
    const { mean: csMean, std: csStd } = meanAndStd(metricsHistory.centerShifts);

    const baseMD = stability.maxMeanDiff;
    const baseCS = stability.maxCenterShift;

    // Stats-based cap with base floor and time-based relaxation
    const mdCap = Math.min(baseMD * relax, (mdMean || 0) + 2.5 * (mdStd || 0));
    const csCap = Math.min(baseCS * relax, (csMean || 0) + 2.5 * (csStd || 0));

    // Require more stable frames if thresholds are significantly relaxed
    const relaxFactor = Math.max(mdCap / baseMD || 1, csCap / baseCS || 1);
    const framesRequired = relaxFactor > 1.2 ? Math.min(stability.requiredStableFrames + 2, 6) : stability.requiredStableFrames;

    return { thrMeanDiff: Math.max(baseMD, mdCap || baseMD), thrCenterShift: Math.max(baseCS, csCap || baseCS), framesRequired };
  }

  function suggestInstruction({ isLumaOk, meanDiff, centerShift, alignmentScore }) {
    if (!isLumaOk) return 'Improve lighting (too dark/bright)';
    if (alignmentScore > 0.3) return 'Center your finger within the guide';
    if (centerShift > stability.maxCenterShift) return 'Hold steady';
    if (meanDiff > stability.maxMeanDiff) return 'Hold steady';
    return 'Align and hold steady…';
  }

  function analyzeFingerprint(canvas) {
    // Downsample for analysis
    const aw = 200;
    const ah = Math.round((canvas.height / canvas.width) * aw);
    const t = document.createElement('canvas');
    t.width = aw; t.height = ah;
    const tc = t.getContext('2d', { willReadFrequently: true });
    tc.drawImage(canvas, 0, 0, canvas.width, canvas.height, 0, 0, aw, ah);
    const img = tc.getImageData(0, 0, aw, ah);
    const data = img.data;

    // Skin ratio using YCrCb thresholds
    let skinCount = 0;
    let gray = new Uint8ClampedArray(aw * ah);
    for (let i = 0, p = 0; i < data.length; i += 4, p++) {
      const r = data[i], g = data[i+1], b = data[i+2];
      const y  =  0.299*r + 0.587*g + 0.114*b;
      const cb = 128 - 0.168736*r - 0.331264*g + 0.5*b;
      const cr = 128 + 0.5*r - 0.418688*g - 0.081312*b;
      if (cr >= 133 && cr <= 173 && cb >= 77 && cb <= 127) skinCount++;
      gray[p] = y;
    }
    const skinRatio = skinCount / (aw * ah);

    // Sobel edge stats
    let edgeCount = 0;
    let edgeSum = 0;
    const sobelT = 28; // edge threshold
    for (let y = 1; y < ah - 1; y++) {
      for (let x = 1; x < aw - 1; x++) {
        const i = y * aw + x;
        const g00 = gray[i - aw - 1], g01 = gray[i - aw], g02 = gray[i - aw + 1];
        const g10 = gray[i - 1],      /* i */     g12 = gray[i + 1];
        const g20 = gray[i + aw - 1], g21 = gray[i + aw], g22 = gray[i + aw + 1];
        const gx = (g02 + 2*g12 + g22) - (g00 + 2*g10 + g20);
        const gy = (g20 + 2*g21 + g22) - (g00 + 2*g01 + g02);
        const mag = Math.hypot(gx, gy);
        edgeSum += mag;
        if (mag > sobelT) edgeCount++;
      }
    }
    const edgePixels = (aw - 2) * (ah - 2);
    const edgeMean = edgeSum / edgePixels;
    const edgePercent = edgeCount / edgePixels;

    // Ridge transitions across central rows
    const rowsToCheck = 5;
    const startRow = Math.max(2, Math.floor(ah * 0.45));
    let totalTransitions = 0;
    for (let k = 0; k < rowsToCheck; k++) {
      const y = Math.min(ah - 3, startRow + k);
      let row = new Array(aw);
      let sum = 0;
      for (let x = 0; x < aw; x++) { const v = gray[y * aw + x]; row[x] = v; sum += v; }
      const mean = sum / aw;
      // Simple smoothing
      for (let x = 1; x < aw - 1; x++) row[x] = (row[x-1] + row[x] + row[x+1]) / 3;
      let prevSign = 0, transitions = 0;
      for (let x = 0; x < aw; x++) {
        const d = row[x] - mean;
        const sign = d > 6 ? 1 : d < -6 ? -1 : 0; // hysteresis
        if (sign !== 0 && sign !== prevSign && prevSign !== 0) transitions++;
        if (sign !== 0) prevSign = sign;
      }
      totalTransitions += transitions;
    }
    const avgTransitions = totalTransitions / rowsToCheck;

    // Heuristic gates tuned for fingerprints
    const skinOk = skinRatio >= 0.40 && skinRatio <= 0.95;
    const edgeOk = edgePercent >= 0.08 && edgePercent <= 0.60 && edgeMean >= 12;
    // Expect many ridge transitions across width=200 after smoothing
    const transOk = avgTransitions >= 20 && avgTransitions <= 180;

    return { skinRatio, edgePercent, edgeMean, avgTransitions, passes: skinOk && edgeOk && transOk };
  }

  function varianceOfLaplacian(canvas) {
    // Downsample for speed
    const targetW = 300;
    const targetH = Math.round((canvas.height / canvas.width) * targetW);
    const t = document.createElement('canvas');
    t.width = targetW; t.height = targetH;
    const c = t.getContext('2d', { willReadFrequently: true });
    c.drawImage(canvas, 0, 0, canvas.width, canvas.height, 0, 0, targetW, targetH);
    const img = c.getImageData(0, 0, targetW, targetH);
    const data = img.data;
    const gray = new Float32Array(targetW * targetH);
    for (let i = 0, p = 0; i < data.length; i += 4, p++) {
      gray[p] = 0.2126 * data[i] + 0.7152 * data[i+1] + 0.0722 * data[i+2];
    }
    // 3x3 Laplacian kernel
    const k = [0, 1, 0, 1, -4, 1, 0, 1, 0];
    const out = new Float32Array(targetW * targetH);
    for (let y = 1; y < targetH - 1; y++) {
      for (let x = 1; x < targetW - 1; x++) {
        const i = y * targetW + x;
        let acc = 0;
        acc += k[0] * gray[i - targetW - 1];
        acc += k[1] * gray[i - targetW];
        acc += k[2] * gray[i - targetW + 1];
        acc += k[3] * gray[i - 1];
        acc += k[4] * gray[i];
        acc += k[5] * gray[i + 1];
        acc += k[6] * gray[i + targetW - 1];
        acc += k[7] * gray[i + targetW];
        acc += k[8] * gray[i + targetW + 1];
        out[i] = acc;
      }
    }
    // Variance
    let sum = 0, sum2 = 0, n = (targetW - 2) * (targetH - 2);
    for (let y = 1; y < targetH - 1; y++) {
      for (let x = 1; x < targetW - 1; x++) {
        const v = out[y * targetW + x];
        sum += v; sum2 += v * v;
      }
    }
    const mean = sum / n;
    return (sum2 / n) - (mean * mean);
  }

  function refineCropBySkin(srcCanvas, guideX, guideY, guideW, guideH) {
    // Analyze inside guide ROI at low resolution to estimate a tight bounding box of skin
    const roiScale = 200 / guideW;
    const dw = Math.max(40, Math.round(guideW * roiScale));
    const dh = Math.max(40, Math.round(guideH * roiScale));
    const t = document.createElement('canvas');
    t.width = dw; t.height = dh;
    const c = t.getContext('2d', { willReadFrequently: true });
    c.drawImage(srcCanvas, guideX, guideY, guideW, guideH, 0, 0, dw, dh);
    const img = c.getImageData(0, 0, dw, dh);
    const data = img.data;
    const bin = new Uint8Array(dw * dh);
    // Skin mask
    for (let i = 0, p = 0; i < data.length; i += 4, p++) {
      const r = data[i], g = data[i+1], b = data[i+2];
      const cb = 128 - 0.168736*r - 0.331264*g + 0.5*b;
      const cr = 128 + 0.5*r - 0.418688*g - 0.081312*b;
      bin[p] = (cr >= 133 && cr <= 173 && cb >= 77 && cb <= 127) ? 1 : 0;
    }
    // Column/row densities -> bounding box
    const colSum = new Uint16Array(dw);
    const rowSum = new Uint16Array(dh);
    for (let y = 0; y < dh; y++) {
      for (let x = 0; x < dw; x++) {
        const v = bin[y * dw + x];
        colSum[x] += v;
        rowSum[y] += v;
      }
    }
    const colThresh = Math.max(1, Math.round(dh * 0.08));
    const rowThresh = Math.max(1, Math.round(dw * 0.08));
    let x0 = 0, x1 = dw - 1, y0 = 0, y1 = dh - 1;
    while (x0 < dw && colSum[x0] < colThresh) x0++;
    while (x1 > x0 && colSum[x1] < colThresh) x1--;
    while (y0 < dh && rowSum[y0] < rowThresh) y0++;
    while (y1 > y0 && rowSum[y1] < rowThresh) y1--;

    // Add margin
    const margin = 8;
    x0 = Math.max(0, x0 - margin); y0 = Math.max(0, y0 - margin);
    x1 = Math.min(dw - 1, x1 + margin); y1 = Math.min(dh - 1, y1 + margin);

    // Validate reasonable size
    const bw = x1 - x0 + 1;
    const bh = y1 - y0 + 1;
    if (bw < dw * 0.2 || bh < dh * 0.2) return null;

    // Map back to src coordinates
    const scaleBack = guideW / dw;
    const cropX = Math.round(guideX + x0 * scaleBack);
    const cropY = Math.round(guideY + y0 * scaleBack);
    const cropW = Math.round(bw * scaleBack);
    const cropH = Math.round(bh * scaleBack);
    return { x: cropX, y: cropY, w: cropW, h: cropH };
  }

  function computeMetrics(imgData, prevImgData) {
    const data = imgData.data;
    const len = data.length;

    let sumLuma = 0;
    let meanDiff = 0;

    // Center-of-mass (brightness-weighted)
    let sumW = 0;
    let sumX = 0;
    let sumY = 0;

    const w = imgData.width;
    const h = imgData.height;

    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const i = (y * w + x) * 4;
        const r = data[i + 0];
        const g = data[i + 1];
        const b = data[i + 2];
        const luma = 0.2126 * r + 0.7152 * g + 0.0722 * b;
        sumLuma += luma;

        const weight = luma + 1e-3;
        sumW += weight;
        sumX += weight * x;
        sumY += weight * y;

        if (prevImgData) {
          const pr = prevImgData.data[i + 0];
          const pg = prevImgData.data[i + 1];
          const pb = prevImgData.data[i + 2];
          // Fast abs difference in luma space
          const pl = 0.2126 * pr + 0.7152 * pg + 0.0722 * pb;
          meanDiff += Math.abs(luma - pl);
        }
      }
    }

    const pixels = w * h;
    const lumaMean = sumLuma / pixels;
    if (prevImgData) meanDiff = meanDiff / pixels; else meanDiff = 255; // first frame considered unstable

    const centerOfMass = {
      x: sumW > 0 ? (sumX / sumW) : w / 2,
      y: sumW > 0 ? (sumY / sumW) : h / 2,
    };

    return { meanDiff, lumaMean, centerOfMass };
  }

  async function captureFromGuide() {
    // Ensure frame canvas matches overlay size
    frameCanvas.width = overlayEl.width;
    frameCanvas.height = overlayEl.height;
    frameCtx.save();
    frameCtx.clearRect(0, 0, frameCanvas.width, frameCanvas.height);

    // Draw mirrored video with CSS-like cover
    const vw = videoEl.videoWidth;
    const vh = videoEl.videoHeight;
    if (!vw || !vh) { frameCtx.restore(); return; }
    const fw = frameCanvas.width;
    const fh = frameCanvas.height;
    const scale = Math.max(fw / vw, fh / vh);
    const dw = Math.floor(vw * scale);
    const dh = Math.floor(vh * scale);
    const dx = Math.floor((fw - dw) / 2);
    const dy = Math.floor((fh - dh) / 2);
    frameCtx.translate(fw, 0);
    frameCtx.scale(-1, 1);
    frameCtx.drawImage(videoEl, 0, 0, vw, vh, fw - dx - dw, dy, dw, dh);
    frameCtx.restore();

    // Crop inside the guide using a refined skin-based bounding box, fallback to full guide
    const { guideX, guideY, guideW, guideH } = lastGuide;
    const refined = refineCropBySkin(frameCanvas, guideX, guideY, guideW, guideH);
    const srcX = refined ? refined.x : guideX;
    const srcY = refined ? refined.y : guideY;
    const srcW = refined ? refined.w : guideW;
    const srcH = refined ? refined.h : guideH;
    const tw = captureCanvas.width;
    const th = captureCanvas.height;
    captureCtx.clearRect(0, 0, tw, th);
    captureCtx.drawImage(frameCanvas, srcX, srcY, srcW, srcH, 0, 0, tw, th);

    // Validate that the crop looks like a fingerprint
    const fp = analyzeFingerprint(captureCanvas);
    const sharpness = varianceOfLaplacian(captureCanvas);
    if (!fp.passes || sharpness < 18.0) {
      instructionsEl.textContent = 'Place fingertip fully inside guide and hold steady';
      throw new Error('Fingerprint heuristics failed');
    }

    const { blob, quality } = await compressToTarget(captureCanvas, 100_000);
    const url = URL.createObjectURL(blob);
    const sizeKB = Math.round(blob.size / 1024);
    captured = { url, blob, quality, sizeKB };
  }

  function toBlob(canvas, type, quality) {
    return new Promise((resolve) => canvas.toBlob(resolve, type, quality));
  }

  async function compressToTarget(canvas, maxBytes) {
    let q = 1.0;
    let lastBlob = await toBlob(canvas, 'image/jpeg', q);
    if (!lastBlob) throw new Error('Compression failed');

    // Mirror android quality stepdowns based on size thresholds
    while (lastBlob.size > maxBytes && q > 0.30) {
      const size = lastBlob.size;
      if (size > 140_000) q -= 0.06;
      else if (size > 130_000) q -= 0.05;
      else if (size > 120_000) q -= 0.04;
      else if (size > 110_000) q -= 0.03;
      else q -= 0.02;

      q = Math.max(q, 0.30);
      lastBlob = await toBlob(canvas, 'image/jpeg', q);
      if (!lastBlob) throw new Error('Compression failed');
    }
    return { blob: lastBlob, quality: q };
  }

  function showPreview() {
    if (!captured) return;
    previewImg.src = captured.url;
    downloadLink.href = captured.url;
    previewModal.classList.remove('hidden');
  }
  function hidePreview() {
    previewModal.classList.add('hidden');
  }

  function showProgress(text) {
    progressBadge.textContent = text || 'Capturing…';
    progressBadge.style.display = 'block';
  }
  function hideProgress() {
    progressBadge.style.display = 'none';
  }

  function resizeOverlayToVideo() {
    const rect = viewportEl.getBoundingClientRect();
    overlayEl.width = Math.floor(rect.width);
    overlayEl.height = Math.floor(rect.height);
    drawOverlay();
  }

  async function startCamera() {
    if (running) return;
    setRunningState(true);
    try {
      mediaStream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: { ideal: 'environment' },
          width: { ideal: 1280 },
          height: { ideal: 720 },
        },
        audio: false,
      });
      videoEl.srcObject = mediaStream;
      await videoEl.play();
      captured = null;
      bestScore = Number.POSITIVE_INFINITY;
      stableCount = 0;
      prevFilteredCenter = null;
      metricsHistory.meanDiffs.length = 0;
      metricsHistory.centerShifts.length = 0;
      scanStartAt = Date.now();
      resizeOverlayToVideo();
      loop();
    } catch (err) {
      console.error(err);
      alert('Unable to start camera: ' + err.message);
      setRunningState(false);
    }
  }

  function stopCamera() {
    setRunningState(false);
    if (rafId) cancelAnimationFrame(rafId);
    const tracks = mediaStream ? mediaStream.getTracks() : [];
    tracks.forEach(t => t.stop());
    mediaStream = null;
  }

  function loop() {
    if (!running) return;
    analyzeFrame();
    drawOverlay();
    rafId = requestAnimationFrame(loop);
  }

  btnStart.addEventListener('click', startCamera);
  btnStop.addEventListener('click', stopCamera);
  btnRetake.addEventListener('click', () => {
    if (captured) { URL.revokeObjectURL(captured.url); }
    captured = null;
    hidePreview();
    updateKV();
  });

  window.addEventListener('resize', resizeOverlayToVideo);
  // Initial overlay draw
  setTimeout(resizeOverlayToVideo, 0);
</script>
</body>
</html>


